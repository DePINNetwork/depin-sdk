// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round uint64) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"9SMOgKoBAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
